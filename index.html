
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        #map { height: 100vh; margin: 0; }
        .leaflet-popup-content h3 {
            margin: 0;
            font-size: 1.1em;
            color: #2a4d9f;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
        const map = L.map('map').setView([46, 14.5], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        const geojsonFiles = [{"url":"merged.geojson","name":"test all"}]
       

        function showDetails(button) {
            const detailsDiv = button.nextElementSibling;
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                button.textContent = 'Hide details';
            } else {
                detailsDiv.style.display = 'none';
                button.textContent = 'See details';
            }
        }
        

        fetch('merged.geojson')
        .then(response => response.json())
    .then(geojsonData => {

        geojsonData.features.forEach(feature => {
            const geometry = feature.geometry;
            if (!geometry) return;

            const allCoordinates = [];

            // Extract coordinates for each LineString
            if (geometry.type === 'LineString') {
                geometry.coordinates.forEach(coord => {
                    const [lon, lat] = coord;
                    allCoordinates.push([lat, lon]);
                });
            }

            // Only draw if there are multiple points
            if (allCoordinates.length > 1) {
                const firstSegment = allCoordinates.slice(2, allCoordinates.length);
                const polyline = L.polyline(firstSegment, {
                    color: 'blue',
                    weight: 3,
                    opacity: 1,
                    smoothFactor: 1
                }).addTo(map);

                // Toggle and popup logic
                polyline.on('click', function () {
                    const currentColor = polyline.options.color;
                    polyline.setStyle({ color: currentColor === 'blue' ? 'red' : 'blue' });
                    polyline.bringToFront();

                    const props = feature.properties || {};
                    const propsHtml = Object.entries(props)
                        .filter(([key]) => key !== 'ele' && key !== 'type' && key !== 'sourceFile')
                        .map(([key, value]) => {
                            if (key.toLowerCase() === 'descriptions') {
                                try {
                                    let unescaped = value
                                        .replace(/\\"/g, '"')
                                        .replace(/\\n/g, '');

                                    // ðŸ§¹ Remove OruxMaps header, <hr>, and <h2> sections
                                    unescaped = unescaped
                                        .replace(/<h1[^>]*>.*?<\/h1>/gi, '')
                                        .replace(/<h2[^>]*>.*?<\/h2>/gi, '')
                                        .replace(/<hr[^>]*>/gi, '')
                                        .replace(/^(?:\s*<br\s*\/?>){1,2}/i, '')
                                        .replace(/<p>/gi, '<p style="margin:2px 0;">');
                                        

                                    // ðŸ§½ Remove empty <p> tags
                                    unescaped = unescaped.replace(/<p>\s*<\/p>/gi, '');

                                    return unescaped.trim();
                                } catch {
                                    return value;
                                }
                            }
                            return '<strong>' + key + ':</strong> ' + value;
                        })
                        .join('<br>');

                        const rawName = props.sourceFile || feature.properties.name || 'Unnamed Track';
                        // Remove everything after '__' if it exists
                        const name = rawName.split('__')[0].trim();
                    
                    const popupContent = `
                        <h3 style="margin:0; font-size:1.1em;">${name}</h3>
                        <button onclick="showDetails(this)" style="margin-top:5px; padding:4px 8px;">See details</button>
                        <div class="details" style="display:none; margin-top:8px;">${propsHtml}</div>
                    `;

                    polyline.bindPopup(popupContent).openPopup();
                });
            }
        });

        // Fit map to all features
        const bounds = L.geoJSON(geojsonData).getBounds();
        if (bounds.isValid()) map.fitBounds(bounds);
    })
    .catch(err => console.error('Error loading merged.geojson:', err));
    </script>
</body>
</html>
