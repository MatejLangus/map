
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
            #map { height: 100vh; margin: 0; }

/* Loading overlay */
#loading {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255,255,255,0.85);
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 22px;
    font-weight: bold;
    color: #333;
}

.spinner {
    border: 6px solid #ddd;
    border-top: 6px solid #2a4d9f;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 0.8s linear infinite;
    margin-right: 12px;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
        #map { height: 100vh; margin: 0; }
        .leaflet-popup-content h3 {
            margin: 0;
            font-size: 1.1em;
            color: #2a4d9f;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div> Loading tracks...
    </div>
    <div id="map"></div>
    <script>

document.getElementById("loading").style.display = "flex"; // show

fetch('merged.geojson')
    .then(response => response.json())
    .then(geojsonData => {

        // --- your existing drawing code here ---

        // Fit bounds after drawing
        const bounds = L.geoJSON(geojsonData).getBounds();
        if (bounds.isValid()) map.fitBounds(bounds);

        // Hide loading screen when finished
        document.getElementById("loading").style.display = "none";
    })
    .catch(err => {
        console.error('Error loading merged.geojson:', err);
        document.getElementById("loading").innerHTML =
            "<div style='color:red;'>Failed to load data.</div>";
    });



        const map = L.map('map').setView([46, 14.5], 6);
        // Multiple base map layers
        const baseLayers = {
            "OSM Standard": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }),

            "OSM Topo": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenTopoMap contributors'
            }),

            "CyclOSM": L.tileLayer('https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png', {
            attribution: 'Â© CyclOSM, OpenStreetMap contributors'
             }),

        };

        const overlays = {
            "Hiking Trails": L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {
                attribution: 'Â© Waymarked Trails, OpenStreetMap contributors'
            })
        };



        // Default map layer
        baseLayers["OSM Standard"].addTo(map);

        // Layer chooser UI
        //L.control.layers(baseLayers).addTo(map);

        L.control.layers(baseLayers, overlays, { collapsed: true }).addTo(map);

        const geojsonFiles = [{"url":"merged.geojson","name":"test all"}]
       

        function showDetails(button) {
            const detailsDiv = button.nextElementSibling;
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                button.textContent = 'Hide details';
            } else {
                detailsDiv.style.display = 'none';
                button.textContent = 'See details';
            }
        }
        

        fetch('merged.geojson')
        .then(response => response.json())
    .then(geojsonData => {

        geojsonData.features.forEach(feature => {
            const geometry = feature.geometry;
            if (!geometry) return;

            const allCoordinates = [];

            // Extract coordinates for each LineString
            if (geometry.type === 'LineString') {
                geometry.coordinates.forEach(coord => {
                    const [lon, lat] = coord;
                    allCoordinates.push([lat, lon]);
                });
            }

            // Only draw if there are multiple points
            if (allCoordinates.length > 1) {
                const firstSegment = allCoordinates.slice(2, allCoordinates.length);
                const polyline = L.polyline(firstSegment, {
                    color: 'blue',
                    weight: 3,
                    opacity: 1,
                    smoothFactor: 1
                }).addTo(map);

                // Toggle and popup logic
                polyline.on('click', function () {
                    const currentColor = polyline.options.color;
                    polyline.setStyle({ color: currentColor === 'blue' ? 'red' : 'blue' });
                    polyline.bringToFront();

                    const props = feature.properties || {};
                    const propsHtml = Object.entries(props)
                        .filter(([key]) => key !== 'ele' && key !== 'type' && key !== 'sourceFile')
                        .map(([key, value]) => {
                            if (key.toLowerCase() === 'descriptions') {
                                try {
                                    let unescaped = value
                                        .replace(/\\"/g, '"')
                                        .replace(/\\n/g, '');

                                    // ðŸ§¹ Remove OruxMaps header, <hr>, and <h2> sections
                                    unescaped = unescaped
                                        .replace(/<h1[^>]*>.*?<\/h1>/gi, '')
                                        .replace(/<h2[^>]*>.*?<\/h2>/gi, '')
                                        .replace(/<hr[^>]*>/gi, '')
                                        .replace(/^(?:\s*<br\s*\/?>){1,2}/i, '')
                                        .replace(/<p>/gi, '<p style="margin:2px 0;">');
                                        

                                    // ðŸ§½ Remove empty <p> tags
                                    unescaped = unescaped.replace(/<p>\s*<\/p>/gi, '');

                                    return unescaped.trim();
                                } catch {
                                    return value;
                                }
                            }
                            return '<strong>' + key + ':</strong> ' + value;
                        })
                        .join('<br>');

                        const rawName = props.sourceFile || feature.properties.name || 'Unnamed Track';
                        // Remove everything after '__' if it exists
                        const name = rawName.split('__')[0].trim();
                    
                    const popupContent = `
                        <h3 style="margin:0; font-size:1.1em;">${name}</h3>
                        <button onclick="showDetails(this)" style="margin-top:5px; padding:4px 8px;">See details</button>
                        <div class="details" style="display:none; margin-top:8px;">${propsHtml}</div>
                    `;

                    polyline.bindPopup(popupContent).openPopup();
                });
            }
        });

        // Fit map to all features
        const bounds = L.geoJSON(geojsonData).getBounds();
        if (bounds.isValid()) map.fitBounds(bounds);
    })
    .catch(err => console.error('Error loading merged.geojson:', err));
    </script>
</body>
</html>
